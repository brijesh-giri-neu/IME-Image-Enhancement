package imeprogram.model;

/**
 * This interface represents a 24-bit Image with Red, Green, and Blue channels. And operations that
 * can be performed on it.
 */
public interface IImage extends IReadOnlyImage {

  /**
   * Gets the value of a specific channel at a given pixel position.
   *
   * @param horizontalPos The column (horizontal position) of the pixel.
   * @param verticalPos   The verticalPos (vertical position) of the pixel.
   * @param channel       The color channel to retrieve (0 for Red, 1 for Green, 2 for Blue).
   * @return The value of the specified channel at the given pixel position.
   * @throws IndexOutOfBoundsException If the provided horizontalPos or verticalPos values are out
   *                                   of bounds.
   * @throws IllegalArgumentException  If an invalid channel value is provided.
   */
  int getValueAtPixel(int horizontalPos, int verticalPos, int channel)
      throws IndexOutOfBoundsException, IllegalArgumentException;

  /**
   * Gets the width of the Image.
   *
   * @return the width of the Image.
   */
  int getWidth();

  /**
   * Gets the height of the Image.
   *
   * @return the height of the Image.
   */
  int getHeight();

  /**
   * Return an IImage that represents a component of this image.
   *
   * @param component the component to represent.
   * @return an IImage that represents a component of this image.
   */
  IImage getComponent(ImageComponent component);

  /**
   * Return an IImage where values for all 3 channels are calculated by using the Value function:
   * MAX(R,G,B).
   *
   * @return an IImage where values for all 3 channels are calculated by using the Value function:
   *     MAX(R,G,B).
   */
  IImage getValueComponent();

  /**
   * Return an IImage where values for all 3 channels are calculated by using the Intensity
   * function: AVG(R,G,B).
   *
   * @return an IImage where values for all 3 channels are calculated by using the Intensity
   *     function: AVG(R,G,B).
   */
  IImage getIntensityComponent();

  /**
   * Return an IImage where values for all 3 channels are calculated by using the Luma function.
   *
   * @return an IImage where values for all 3 channels are calculated by using the Luma function.
   */
  IImage getLumaComponent();

  /**
   * Return an IImage that is generated by horizontally flipping this IImage.
   *
   * @return a horizontally flipped version of this IImage.
   */
  IImage flipHorizontal();

  /**
   * Return an IImage that is generated by vertically flipping this IImage.
   *
   * @return a vertically flipped version of this IImage.
   */
  IImage flipVertical();

  /**
   * Return an IImage that is generated by applying a constant increment value to each pixel of this
   * IImage.
   *
   * @param increment the constant increment value to be applied to each pixel.
   * @return a new IImage with modified pixel values
   */
  IImage brighten(int increment);

  /**
   * Return the individual [R,G,B] components of this IImage. Each component will be an IImage where
   * the other component values are set to 0.
   *
   * @return an array of exactly THREE IImages in the mentioned order : index 0 -> Red Component,
   *     index 1 -> Green Component, index 2 -> Blue Component
   */
  IImage[] splitRGB();

  /**
   * Overwrite this IImage by combining the red, green, and blue components from the given IImages.
   * Picks one channel from each of the given arguments.
   *
   * @param red   IImage whose Red component is selected.
   * @param green IImage whose Green component is selected.
   * @param blue  IImage whose Blue component is selected.
   * @throws IllegalArgumentException If the input images have different dimensions.
   */
  void combineRGB(IImage red, IImage green, IImage blue) throws IllegalArgumentException;

  /**
   * Applies the given filter to the image.
   *
   * @param imageFilter the filter to apply to the image.
   * @return a new IImage with the given filter applied.
   */
  IImage applyFilter(Filter imageFilter);

  /**
   * Applies a Grayscale filter to the image using the conversion formula: R'=G'=B'=0.2126R +
   * 0.7152G + 0.0722B.
   *
   * @return a new IImage with the Grayscale filter applied.
   */
  IImage convertToGrayscale();

  /**
   * Applies a sepia tone effect to the image.
   *
   * @return a new IImage with the sepia tone filter applied.
   */
  IImage convertToSepia();

  /**
   * Returns a 256x256 line graph representing the normalized histogram of this IImage.
   *
   * @param graph the graphics used to draw the histogram.
   * @return a 256x256 line graph representing the normalized histogram of this IImage.
   */
  IImage getHistogram(ILineGraph graph);

  /**
   * Color corrects an Image by aligning the meaningful peaks of its histogram. The corrected peak
   * position in its histogram is determined by the average of peak pixel values across channels
   * i.e. AVG(PixelValue(Peak_Red), PixelValue(Peak_Green), PixelValue(Peak_Blue))
   *
   * @return a new IImage with aligned histogram peaks, that visually looks black and white.
   */
  IImage colorCorrect();

  /**
   * Performs levels adjustment operation in the histogram of an image using the given black, mid,
   * and white levels. Valid black, mid, and white levels are in the [0,255] range in ascending
   * order i.e. black < mid < white, and all of them are between [0,255].
   *
   * @param black the horizontal position of black level i.e. shadows. Also known as, the furthest
   *              horizontal position of frequency 0 in the histogram.
   * @param mid   the horizontal position of mid-level. Also known as, the furthest horizontal
   *              position of frequency 128 in the histogram.
   * @param white the horizontal position of white level i.e. highlights. Also known as, the
   *              furthest horizontal position of frequency 255 in the histogram.
   * @return a new IImage with adjusted levels that has enhanced contrast.
   * @throws IllegalArgumentException If the provided black, mid, and white levels are not valid.
   */
  IImage adjustLevels(int black, int mid, int white) throws IllegalArgumentException;

  /**
   * Merges this image with the other image in that specific order, in the given split ratio.
   * Dimensions of both the images must match for this operation. Result image gets its left portion
   * from this image and its right portion from the other image.
   *
   * @param other      the other image to merge with.
   * @param splitRatio the ratio of this image in the result, which is a percentage of horizontal
   *                   width. This image contributes [0, splitRatio] of its width to the result
   *                   image and the other image contributes [splitRatio, 100] of its width to the
   *                   result image.
   * @return an IImage that contains this image in its left portion and the other image in its right
   *     portion.
   * @throws IllegalArgumentException If the dimensions of this image and the other image don't
   *                                  match. Or if the splitRatio is invalid (<0 or >100).
   */
  IImage splitView(IImage other, int splitRatio) throws IllegalArgumentException;

  /**
   * Applies the haar transform to the image and compresses it.
   *
   * @param ratio the compression percentage.
   * @return a new IImage with the haar transform applied.
   */
  IImage haarCompress(int ratio) throws IllegalArgumentException;

  /**
   * Represents different components of the IImage.
   */
  enum ImageComponent {
    // 0 represents RED
    RED(0),
    // 1 represents GREEN
    GREEN(1),
    // 2 represents BLUE
    BLUE(2);

    private final int index;

    /**
     * Initializes the index for this ImageComponent.
     *
     * @param index the index for this ImageComponent.
     */
    ImageComponent(int index) {
      this.index = index;
    }

    int getChannel() {
      return index;
    }
  }

  /**
   * Represents different filter kernels supported by our IImage.
   */
  enum Filter {
    GAUSSIAN_BLUR(new double[][]{
        {1.0 / 16, 2.0 / 16, 1.0 / 16},
        {2.0 / 16, 4.0 / 16, 2.0 / 16},
        {1.0 / 16, 2.0 / 16, 1.0 / 16}}),
    SHARPEN(new double[][]{
        {-1.0 / 8, -1.0 / 8, -1.0 / 8, -1.0 / 8, -1.0 / 8},
        {-1.0 / 8, 1.0 / 4, 1.0 / 4, 1.0 / 4, -1.0 / 8},
        {-1.0 / 8, 1.0 / 4, 1.0, 1.0 / 4, -1.0 / 8},
        {-1.0 / 8, 1.0 / 4, 1.0 / 4, 1.0 / 4, -1.0 / 8},
        {-1.0 / 8, -1.0 / 8, -1.0 / 8, -1.0 / 8, -1.0 / 8}});

    private final double[][] kernel;

    /**
     * Initializes the kernel for this Filter.
     *
     * @param kernel the given kernel.
     */
    Filter(double[][] kernel) {
      this.kernel = kernel;
    }

    double[][] getKernel() {
      return kernel;
    }
  }
}
